// js/multiplayer.js

// 1. Import Firebase SDKs (Modular)
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { 
    getDatabase, ref, set, get, update, onValue, remove, onDisconnect, child 
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";

// --- CONFIGURATION START ---
// ðŸ”´ TODO: Paste your Firebase Config object here
const firebaseConfig = {
    apiKey: "YOUR_API_KEY",
    authDomain: "your-project.firebaseapp.com",
    databaseURL: "https://your-project-default-rtdb.firebaseio.com",
    projectId: "your-project",
    storageBucket: "your-project.appspot.com",
    messagingSenderId: "123456789",
    appId: "1:123456789:web:abcdef123456"
};
// --- CONFIGURATION END ---

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

export default class MultiplayerSession {
    constructor(gameType) {
        this.gameType = gameType; // e.g., 'memory-match'
        this.sessionId = null;
        this.playerNumber = null; // 1 or 2
        this.playerName = null;
        this.listeners = {
            onPlayerJoined: [],
            onGameStateChange: [],
            onDisconnect: []
        };
        this.sessionRef = null;
    }

    /**
     * Tries to reconnect to an existing session from localStorage
     */
    static async autoReconnect(gameType) {
        const savedSession = localStorage.getItem(`session_${gameType}`);
        if (!savedSession) return null;

        const { sessionId, playerNumber, playerName } = JSON.parse(savedSession);
        
        // Verify if session still exists in Firebase
        const snapshot = await get(ref(db, `sessions/${sessionId}`));
        if (snapshot.exists()) {
            const session = new MultiplayerSession(gameType);
            session.sessionId = sessionId;
            session.playerNumber = playerNumber;
            session.playerName = playerName;
            session.sessionRef = ref(db, `sessions/${sessionId}`);
            
            // Re-attach listeners
            session.listenToSession();
            
            return {
                session: session,
                result: { success: true, gameState: snapshot.val().gameState || {} }
            };
        } else {
            localStorage.removeItem(`session_${gameType}`);
            return null;
        }
    }

    /**
     * Create a new Game Session (Host)
     */
    async createSession(playerName) {
        this.sessionId = this.generateSessionCode();
        this.playerNumber = 1;
        this.playerName = playerName;
        this.sessionRef = ref(db, `sessions/${this.sessionId}`);

        const initialData = {
            created: Date.now(),
            gameType: this.gameType,
            player1: playerName,
            player2: "",
            status: "waiting", // waiting, playing, finished
            gameState: {}
        };

        try {
            await set(this.sessionRef, initialData);
            
            // Remove session if host disconnects before game starts
            onDisconnect(this.sessionRef).remove();

            this.saveToLocal();
            this.listenToSession();
            return { success: true, sessionId: this.sessionId };
        } catch (error) {
            console.error("Firebase Error:", error);
            return { success: false, error: error.message };
        }
    }

    /**
     * Join an existing Game Session
     */
    async joinSession(code, playerName) {
        const sessionId = code.toUpperCase();
        const sessionRef = ref(db, `sessions/${sessionId}`);
        
        try {
            const snapshot = await get(sessionRef);
            
            if (!snapshot.exists()) {
                return { success: false, error: "Game code not found." };
            }

            const data = snapshot.val();
            
            if (data.status !== "waiting") {
                // Allow rejoin if names match (optional, but good for refresh)
                if (data.player2 === playerName) {
                    // It's a rejoin
                } else if (data.player2 !== "") {
                    return { success: false, error: "Game is full." };
                }
            }

            // Update DB with Player 2 info
            await update(sessionRef, {
                player2: playerName,
                status: "playing"
            });

            this.sessionId = sessionId;
            this.playerNumber = 2;
            this.playerName = playerName;
            this.sessionRef = sessionRef;

            // Handle disconnects
            onDisconnect(ref(db, `sessions/${sessionId}/player2State`)).set('disconnected');

            this.saveToLocal();
            this.listenToSession();

            return { success: true, opponentName: data.player1 };
        } catch (error) {
            console.error("Join Error:", error);
            return { success: false, error: error.message };
        }
    }

    /**
     * Listen for Realtime Updates from Firebase
     */
    listenToSession() {
        if (!this.sessionRef) return;

        onValue(this.sessionRef, (snapshot) => {
            const data = snapshot.val();
            if (!data) {
                // Session was deleted
                this.disconnect();
                return;
            }

            // Check if Player 2 joined
            if (this.playerNumber === 1 && data.player2 && data.status === "playing") {
                // Only trigger if we haven't already marked game as active in UI logic
                // But simplified: just emit the event
                this.emit('onPlayerJoined', data.player2);
            }

            // Check for Game State changes
            if (data.gameState) {
                this.emit('onGameStateChange', data.gameState);
            }
        });
    }

    /**
     * Update the shared Game State
     */
    async updateGameState(newState) {
        if (!this.sessionRef) return;
        
        try {
            // We merge the new state with existing state to allow partial updates
            // But Firebase 'update' works on the specific path. 
            // To update specific keys inside gameState, we map them.
            
            // For simplicity in this game, we often update the whole gameState object or specific keys.
            // Let's assume newState is a partial object to merge into /gameState/
            
            const updates = {};
            for (const key in newState) {
                updates[`gameState/${key}`] = newState[key];
            }
            
            await update(this.sessionRef, updates);
        } catch (e) {
            console.error("Update State Error", e);
        }
    }

    /**
     * Helper to generate a 6-char code
     */
    generateSessionCode() {
        const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
        let result = "";
        for (let i = 0; i < 6; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
    }

    saveToLocal() {
        const data = {
            sessionId: this.sessionId,
            playerNumber: this.playerNumber,
            playerName: this.playerName
        };
        localStorage.setItem(`session_${this.gameType}`, JSON.stringify(data));
    }

    async disconnect() {
        localStorage.removeItem(`session_${this.gameType}`);
        if (this.sessionRef) {
            // If host disconnects, maybe delete session? Or just leave.
            // For now, simpler is just to detach listeners.
            // In a real app, you might want to set status to 'finished' or 'disconnected'
        }
        this.sessionId = null;
        this.playerNumber = null;
        this.listeners = {};
    }

    // Event Emitter logic
    on(event, callback) {
        if (this.listeners[event]) {
            this.listeners[event].push(callback);
        }
    }

    emit(event, payload) {
        if (this.listeners[event]) {
            this.listeners[event].forEach(cb => cb(payload));
        }
    }
}
